<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Chart</title>
    <style>
        /* Add some basic styles for the chart */
        body {
            font-family: Arial, sans-serif;
        }

        .bubble {
            fill: steelblue;
            stroke: #fff;
            stroke-width: 1px;
        }

        .tooltip {
            position: absolute;
            text-align: center;
            width: 120px;
            padding: 5px;
            background: lightsteelblue;
            border-radius: 8px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <h2>Football Standings Bubble Chart</h2>
    <div id="chart"></div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        const fetchStandings = async () => {
            const url = 'https://sofascore.p.rapidapi.com/tournaments/get-standings?tournamentId=23&seasonId=37475&type=total';
            const options = {
                method: 'GET',
                headers: {
                    'x-rapidapi-key': '6ed0a534c9mshb4ce6150cf50aa4p1b036bjsnf2a0146c6be0',
                    'x-rapidapi-host': 'sofascore.p.rapidapi.com'
                }
            };

            try {
                const response = await fetch(url, options);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const result = await response.json();

                // Extract the teams and points
                if (result && result.standings && result.standings[0] && result.standings[0].rows) {
                    const teamsData = result.standings[0].rows.map(team => ({
                        name: team.team.name,
                        points: team.points
                    }));

                    // Call function to create the bubble chart
                    createBubbleChart(teamsData);
                } else {
                    console.log('No standings data found.');
                }
            } catch (error) {
                console.error('Error fetching standings:', error);
            }
        };

        const createBubbleChart = (data) => {
            const width = 800;
            const height = 600;

            const svg = d3.select("#chart")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            // Create a scale for bubble size (radius based on points)
            const radiusScale = d3.scaleSqrt()
                .domain([0, d3.max(data, d => d.points)])
                .range([10, 50]);

            // Simulation for bubble layout
            const simulation = d3.forceSimulation(data)
                .force("x", d3.forceX(width / 2).strength(0.05))
                .force("y", d3.forceY(height / 2).strength(0.05))
                .force("charge", d3.forceManyBody().strength(-50))
                .force("collision", d3.forceCollide(d => radiusScale(d.points) + 2))
                .on("tick", ticked);

            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);

            const bubbles = svg.selectAll(".bubble")
                .data(data)
                .enter()
                .append("circle")
                .attr("class", "bubble")
                .attr("r", d => radiusScale(d.points))
                .attr("fill", "steelblue")
                .on("mouseover", (event, d) => {
                    tooltip.transition().duration(200).style("opacity", .9);
                    tooltip.html(d.name + "<br/>Points: " + d.points)
                        .style("left", (event.pageX + 5) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", () => {
                    tooltip.transition().duration(500).style("opacity", 0);
                });

            function ticked() {
                bubbles
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
            }
        };

        // Call the fetch function to get data and create the chart
        fetchStandings();
    </script>
</body>
</html>
